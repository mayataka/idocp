<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>idocp: idocp::UnOCPSolver Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">idocp
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceidocp.html">idocp</a></li><li class="navelem"><a class="el" href="classidocp_1_1_un_o_c_p_solver.html">UnOCPSolver</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classidocp_1_1_un_o_c_p_solver-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">idocp::UnOCPSolver Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Optimal control problem solver by Riccati recursion for "unconstrained" rigid-body systems. "Unconstrained" means that the system does not have either a floating base or any contacts.  
 <a href="classidocp_1_1_un_o_c_p_solver.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="unocp__solver_8hpp_source.html">unocp_solver.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:afb786f07969bd99cc324372f030f3257"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classidocp_1_1_un_o_c_p_solver.html#afb786f07969bd99cc324372f030f3257">UnOCPSolver</a> (const <a class="el" href="classidocp_1_1_robot.html">Robot</a> &amp;robot, const std::shared_ptr&lt; <a class="el" href="classidocp_1_1_cost_function.html">CostFunction</a> &gt; &amp;cost, const std::shared_ptr&lt; <a class="el" href="classidocp_1_1_constraints.html">Constraints</a> &gt; &amp;constraints, const double T, const int N, const int nthreads=1)</td></tr>
<tr class="memdesc:afb786f07969bd99cc324372f030f3257"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct optimal control problem solver.  <a href="classidocp_1_1_un_o_c_p_solver.html#afb786f07969bd99cc324372f030f3257">More...</a><br /></td></tr>
<tr class="separator:afb786f07969bd99cc324372f030f3257"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae53a4a467e9114cb579b1bdda83374f9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classidocp_1_1_un_o_c_p_solver.html#ae53a4a467e9114cb579b1bdda83374f9">UnOCPSolver</a> ()</td></tr>
<tr class="memdesc:ae53a4a467e9114cb579b1bdda83374f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="classidocp_1_1_un_o_c_p_solver.html#ae53a4a467e9114cb579b1bdda83374f9">More...</a><br /></td></tr>
<tr class="separator:ae53a4a467e9114cb579b1bdda83374f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9e3c733d25f4b685695a7e62a85acfb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classidocp_1_1_un_o_c_p_solver.html#aa9e3c733d25f4b685695a7e62a85acfb">~UnOCPSolver</a> ()</td></tr>
<tr class="memdesc:aa9e3c733d25f4b685695a7e62a85acfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="classidocp_1_1_un_o_c_p_solver.html#aa9e3c733d25f4b685695a7e62a85acfb">More...</a><br /></td></tr>
<tr class="separator:aa9e3c733d25f4b685695a7e62a85acfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9236d2fcf876e1a953dedd2450f5299"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classidocp_1_1_un_o_c_p_solver.html#ae9236d2fcf876e1a953dedd2450f5299">UnOCPSolver</a> (const <a class="el" href="classidocp_1_1_un_o_c_p_solver.html">UnOCPSolver</a> &amp;)=default</td></tr>
<tr class="memdesc:ae9236d2fcf876e1a953dedd2450f5299"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default copy constructor.  <a href="classidocp_1_1_un_o_c_p_solver.html#ae9236d2fcf876e1a953dedd2450f5299">More...</a><br /></td></tr>
<tr class="separator:ae9236d2fcf876e1a953dedd2450f5299"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5550e528bd016acd0703ce4ccb5bc24"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classidocp_1_1_un_o_c_p_solver.html">UnOCPSolver</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classidocp_1_1_un_o_c_p_solver.html#aa5550e528bd016acd0703ce4ccb5bc24">operator=</a> (const <a class="el" href="classidocp_1_1_un_o_c_p_solver.html">UnOCPSolver</a> &amp;)=default</td></tr>
<tr class="memdesc:aa5550e528bd016acd0703ce4ccb5bc24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default copy assign operator.  <a href="classidocp_1_1_un_o_c_p_solver.html#aa5550e528bd016acd0703ce4ccb5bc24">More...</a><br /></td></tr>
<tr class="separator:aa5550e528bd016acd0703ce4ccb5bc24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae299e65a49be218904ef003e14d1f67"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classidocp_1_1_un_o_c_p_solver.html#aae299e65a49be218904ef003e14d1f67">UnOCPSolver</a> (<a class="el" href="classidocp_1_1_un_o_c_p_solver.html">UnOCPSolver</a> &amp;&amp;) noexcept=default</td></tr>
<tr class="memdesc:aae299e65a49be218904ef003e14d1f67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default move constructor.  <a href="classidocp_1_1_un_o_c_p_solver.html#aae299e65a49be218904ef003e14d1f67">More...</a><br /></td></tr>
<tr class="separator:aae299e65a49be218904ef003e14d1f67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91e7947bbeddafc689681aad5e48e141"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classidocp_1_1_un_o_c_p_solver.html">UnOCPSolver</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classidocp_1_1_un_o_c_p_solver.html#a91e7947bbeddafc689681aad5e48e141">operator=</a> (<a class="el" href="classidocp_1_1_un_o_c_p_solver.html">UnOCPSolver</a> &amp;&amp;) noexcept=default</td></tr>
<tr class="memdesc:a91e7947bbeddafc689681aad5e48e141"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default move assign operator.  <a href="classidocp_1_1_un_o_c_p_solver.html#a91e7947bbeddafc689681aad5e48e141">More...</a><br /></td></tr>
<tr class="separator:a91e7947bbeddafc689681aad5e48e141"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe837fb85dd75d0c6e653a53e355f34f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classidocp_1_1_un_o_c_p_solver.html#afe837fb85dd75d0c6e653a53e355f34f">initConstraints</a> ()</td></tr>
<tr class="memdesc:afe837fb85dd75d0c6e653a53e355f34f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the inequality constraints, i.e., set slack variables and the Lagrange multipliers of inequality constraints. Based on the current solution.  <a href="classidocp_1_1_un_o_c_p_solver.html#afe837fb85dd75d0c6e653a53e355f34f">More...</a><br /></td></tr>
<tr class="separator:afe837fb85dd75d0c6e653a53e355f34f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae03655825b903cde54473fc0bd8ac87b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classidocp_1_1_un_o_c_p_solver.html#ae03655825b903cde54473fc0bd8ac87b">updateSolution</a> (const double t, const Eigen::VectorXd &amp;q, const Eigen::VectorXd &amp;v, const bool line_search=false)</td></tr>
<tr class="memdesc:ae03655825b903cde54473fc0bd8ac87b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the solution by computing the primal-dual Newon direction.  <a href="classidocp_1_1_un_o_c_p_solver.html#ae03655825b903cde54473fc0bd8ac87b">More...</a><br /></td></tr>
<tr class="separator:ae03655825b903cde54473fc0bd8ac87b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97a45b41171d8f8e5c5e9433e83af8cc"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classidocp_1_1_split_solution.html">SplitSolution</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classidocp_1_1_un_o_c_p_solver.html#a97a45b41171d8f8e5c5e9433e83af8cc">getSolution</a> (const int stage) const</td></tr>
<tr class="memdesc:a97a45b41171d8f8e5c5e9433e83af8cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the const reference to the split solution of a time stage. For example, you can get the const reference to the control input torques at the initial stage via ocp.getSolution(0).u.  <a href="classidocp_1_1_un_o_c_p_solver.html#a97a45b41171d8f8e5c5e9433e83af8cc">More...</a><br /></td></tr>
<tr class="separator:a97a45b41171d8f8e5c5e9433e83af8cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9392797789ec4da3cf042265a547710"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classidocp_1_1_un_o_c_p_solver.html#aa9392797789ec4da3cf042265a547710">getStateFeedbackGain</a> (const int stage, Eigen::MatrixXd &amp;Kq, Eigen::MatrixXd &amp;Kv) const</td></tr>
<tr class="memdesc:aa9392797789ec4da3cf042265a547710"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the state-feedback gain for the control input torques.  <a href="classidocp_1_1_un_o_c_p_solver.html#aa9392797789ec4da3cf042265a547710">More...</a><br /></td></tr>
<tr class="separator:aa9392797789ec4da3cf042265a547710"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adccfbe38c281e3441ae90e2c6dd20769"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classidocp_1_1_un_o_c_p_solver.html#adccfbe38c281e3441ae90e2c6dd20769">setSolution</a> (const std::string &amp;name, const Eigen::VectorXd &amp;value)</td></tr>
<tr class="separator:adccfbe38c281e3441ae90e2c6dd20769"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a592a8755ac101fc896e904cf73847d7e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classidocp_1_1_un_o_c_p_solver.html#a592a8755ac101fc896e904cf73847d7e">clearLineSearchFilter</a> ()</td></tr>
<tr class="memdesc:a592a8755ac101fc896e904cf73847d7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the line search filter.  <a href="classidocp_1_1_un_o_c_p_solver.html#a592a8755ac101fc896e904cf73847d7e">More...</a><br /></td></tr>
<tr class="separator:a592a8755ac101fc896e904cf73847d7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a993867156ec82fb4a192eb8888456314"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classidocp_1_1_un_o_c_p_solver.html#a993867156ec82fb4a192eb8888456314">computeKKTResidual</a> (const double t, const Eigen::VectorXd &amp;q, const Eigen::VectorXd &amp;v)</td></tr>
<tr class="memdesc:a993867156ec82fb4a192eb8888456314"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the KKT residula of the optimal control problem.  <a href="classidocp_1_1_un_o_c_p_solver.html#a993867156ec82fb4a192eb8888456314">More...</a><br /></td></tr>
<tr class="separator:a993867156ec82fb4a192eb8888456314"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7df72212fbb2dfc2a3f70dad39625a3"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classidocp_1_1_un_o_c_p_solver.html#ab7df72212fbb2dfc2a3f70dad39625a3">KKTError</a> ()</td></tr>
<tr class="memdesc:ab7df72212fbb2dfc2a3f70dad39625a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the squared KKT error norm by using previously computed results computed by <a class="el" href="classidocp_1_1_un_o_c_p_solver.html#ae03655825b903cde54473fc0bd8ac87b" title="Updates the solution by computing the primal-dual Newon direction.">updateSolution()</a>. The result is not exactly the same as the squared KKT error norm of the original optimal control problem. The result is the squared norm of the condensed residual. However, this variables is sufficiently close to the original KKT error norm.  <a href="classidocp_1_1_un_o_c_p_solver.html#ab7df72212fbb2dfc2a3f70dad39625a3">More...</a><br /></td></tr>
<tr class="separator:ab7df72212fbb2dfc2a3f70dad39625a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6fa08c3ab38bf18b6337694c69289e4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classidocp_1_1_un_o_c_p_solver.html#ae6fa08c3ab38bf18b6337694c69289e4">isCurrentSolutionFeasible</a> ()</td></tr>
<tr class="memdesc:ae6fa08c3ab38bf18b6337694c69289e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the current solution is feasible under the inequality constraints. Return false if it is not feasible.  <a href="classidocp_1_1_un_o_c_p_solver.html#ae6fa08c3ab38bf18b6337694c69289e4">More...</a><br /></td></tr>
<tr class="separator:ae6fa08c3ab38bf18b6337694c69289e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae636109d5f0c1283cbd30f1bb53175b1"><td class="memItemLeft" align="right" valign="top">std::vector&lt; Eigen::VectorXd &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classidocp_1_1_un_o_c_p_solver.html#ae636109d5f0c1283cbd30f1bb53175b1">getSolution</a> (const std::string &amp;name) const</td></tr>
<tr class="memdesc:ae636109d5f0c1283cbd30f1bb53175b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the solution vector. This function is not suitable for real-time application, e.g., MPC, since this function reconstructs the solution vector object.  <a href="classidocp_1_1_un_o_c_p_solver.html#ae636109d5f0c1283cbd30f1bb53175b1">More...</a><br /></td></tr>
<tr class="separator:ae636109d5f0c1283cbd30f1bb53175b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a581f205f97b4331a451197ba2a011fd5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classidocp_1_1_un_o_c_p_solver.html#a581f205f97b4331a451197ba2a011fd5">printSolution</a> (const std::string &amp;name=&quot;all&quot;, const std::vector&lt; int &gt; frames={}) const</td></tr>
<tr class="memdesc:a581f205f97b4331a451197ba2a011fd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints the variable into console.  <a href="classidocp_1_1_un_o_c_p_solver.html#a581f205f97b4331a451197ba2a011fd5">More...</a><br /></td></tr>
<tr class="separator:a581f205f97b4331a451197ba2a011fd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa669977194770f5488962fdcb26a1e8f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classidocp_1_1_un_o_c_p_solver.html#aa669977194770f5488962fdcb26a1e8f">saveSolution</a> (const std::string &amp;path_to_file, const std::string &amp;name) const</td></tr>
<tr class="memdesc:aa669977194770f5488962fdcb26a1e8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save the variable into file.  <a href="classidocp_1_1_un_o_c_p_solver.html#aa669977194770f5488962fdcb26a1e8f">More...</a><br /></td></tr>
<tr class="separator:aa669977194770f5488962fdcb26a1e8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Optimal control problem solver by Riccati recursion for "unconstrained" rigid-body systems. "Unconstrained" means that the system does not have either a floating base or any contacts. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="afb786f07969bd99cc324372f030f3257"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb786f07969bd99cc324372f030f3257">&#9670;&nbsp;</a></span>UnOCPSolver() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idocp::UnOCPSolver::UnOCPSolver </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classidocp_1_1_robot.html">Robot</a> &amp;&#160;</td>
          <td class="paramname"><em>robot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classidocp_1_1_cost_function.html">CostFunction</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cost</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classidocp_1_1_constraints.html">Constraints</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>nthreads</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct optimal control problem solver. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">robot</td><td><a class="el" href="classidocp_1_1_robot.html" title="Dynamics and kinematics model of robots. Wraps pinocchio::Model and pinocchio::Data....">Robot</a> model. Must be initialized by URDF or XML. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cost</td><td>Shared ptr to the cost function. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">constraints</td><td>Shared ptr to the constraints. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">T</td><td>Length of the horizon. Must be positive. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td>Number of discretization of the horizon. Must be more than 1. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nthreads</td><td>Number of the threads in solving the optimal control problem. Must be positive. Default is 1. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae53a4a467e9114cb579b1bdda83374f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae53a4a467e9114cb579b1bdda83374f9">&#9670;&nbsp;</a></span>UnOCPSolver() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idocp::UnOCPSolver::UnOCPSolver </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default constructor. </p>

</div>
</div>
<a id="aa9e3c733d25f4b685695a7e62a85acfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9e3c733d25f4b685695a7e62a85acfb">&#9670;&nbsp;</a></span>~UnOCPSolver()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idocp::UnOCPSolver::~UnOCPSolver </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destructor. </p>

</div>
</div>
<a id="ae9236d2fcf876e1a953dedd2450f5299"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9236d2fcf876e1a953dedd2450f5299">&#9670;&nbsp;</a></span>UnOCPSolver() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">idocp::UnOCPSolver::UnOCPSolver </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classidocp_1_1_un_o_c_p_solver.html">UnOCPSolver</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default copy constructor. </p>

</div>
</div>
<a id="aae299e65a49be218904ef003e14d1f67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae299e65a49be218904ef003e14d1f67">&#9670;&nbsp;</a></span>UnOCPSolver() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">idocp::UnOCPSolver::UnOCPSolver </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classidocp_1_1_un_o_c_p_solver.html">UnOCPSolver</a> &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default move constructor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a592a8755ac101fc896e904cf73847d7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a592a8755ac101fc896e904cf73847d7e">&#9670;&nbsp;</a></span>clearLineSearchFilter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void idocp::UnOCPSolver::clearLineSearchFilter </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear the line search filter. </p>

</div>
</div>
<a id="a993867156ec82fb4a192eb8888456314"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a993867156ec82fb4a192eb8888456314">&#9670;&nbsp;</a></span>computeKKTResidual()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void idocp::UnOCPSolver::computeKKTResidual </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the KKT residula of the optimal control problem. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>Current time. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">q</td><td>Initial configuration. Size must be <a class="el" href="classidocp_1_1_robot.html#a166a0a0045a2a7815378abd2c4d857f8" title="Returns the dimensiton of the configuration.">Robot::dimq()</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>Initial velocity. Size must be <a class="el" href="classidocp_1_1_robot.html#ada145446117167b302c3fce3ee5b7dea" title="Returns the dimensiton of the velocity, i.e, tangent space.">Robot::dimv()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a97a45b41171d8f8e5c5e9433e83af8cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97a45b41171d8f8e5c5e9433e83af8cc">&#9670;&nbsp;</a></span>getSolution() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classidocp_1_1_split_solution.html">SplitSolution</a>&amp; idocp::UnOCPSolver::getSolution </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>stage</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the const reference to the split solution of a time stage. For example, you can get the const reference to the control input torques at the initial stage via ocp.getSolution(0).u. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">stage</td><td>Time stage of interest. Must be more than 0 and less than N. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Const reference to the split solution of the specified time stage. </dd></dl>

</div>
</div>
<a id="ae636109d5f0c1283cbd30f1bb53175b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae636109d5f0c1283cbd30f1bb53175b1">&#9670;&nbsp;</a></span>getSolution() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;Eigen::VectorXd&gt; idocp::UnOCPSolver::getSolution </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the solution vector. This function is not suitable for real-time application, e.g., MPC, since this function reconstructs the solution vector object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Name of the printed variable. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa9392797789ec4da3cf042265a547710"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9392797789ec4da3cf042265a547710">&#9670;&nbsp;</a></span>getStateFeedbackGain()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void idocp::UnOCPSolver::getStateFeedbackGain </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>stage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>Kq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>Kv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the state-feedback gain for the control input torques. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">stage</td><td>Time stage of interest. Must be more than 0 and less than N-1. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Kq</td><td>Gain with respec to the configuration. Size must be <a class="el" href="classidocp_1_1_robot.html#ada145446117167b302c3fce3ee5b7dea" title="Returns the dimensiton of the velocity, i.e, tangent space.">Robot::dimv()</a> x <a class="el" href="classidocp_1_1_robot.html#ada145446117167b302c3fce3ee5b7dea" title="Returns the dimensiton of the velocity, i.e, tangent space.">Robot::dimv()</a>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Kv</td><td>Gain with respec to the velocity. Size must be <a class="el" href="classidocp_1_1_robot.html#ada145446117167b302c3fce3ee5b7dea" title="Returns the dimensiton of the velocity, i.e, tangent space.">Robot::dimv()</a> x <a class="el" href="classidocp_1_1_robot.html#ada145446117167b302c3fce3ee5b7dea" title="Returns the dimensiton of the velocity, i.e, tangent space.">Robot::dimv()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afe837fb85dd75d0c6e653a53e355f34f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe837fb85dd75d0c6e653a53e355f34f">&#9670;&nbsp;</a></span>initConstraints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void idocp::UnOCPSolver::initConstraints </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes the inequality constraints, i.e., set slack variables and the Lagrange multipliers of inequality constraints. Based on the current solution. </p>

</div>
</div>
<a id="ae6fa08c3ab38bf18b6337694c69289e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6fa08c3ab38bf18b6337694c69289e4">&#9670;&nbsp;</a></span>isCurrentSolutionFeasible()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool idocp::UnOCPSolver::isCurrentSolutionFeasible </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if the current solution is feasible under the inequality constraints. Return false if it is not feasible. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the current solution is feasible under the inequality constraints. false if it is not feasible. </dd></dl>

</div>
</div>
<a id="ab7df72212fbb2dfc2a3f70dad39625a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7df72212fbb2dfc2a3f70dad39625a3">&#9670;&nbsp;</a></span>KKTError()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double idocp::UnOCPSolver::KKTError </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the squared KKT error norm by using previously computed results computed by <a class="el" href="classidocp_1_1_un_o_c_p_solver.html#ae03655825b903cde54473fc0bd8ac87b" title="Updates the solution by computing the primal-dual Newon direction.">updateSolution()</a>. The result is not exactly the same as the squared KKT error norm of the original optimal control problem. The result is the squared norm of the condensed residual. However, this variables is sufficiently close to the original KKT error norm. </p>
<dl class="section return"><dt>Returns</dt><dd>The squared norm of the condensed KKT residual. </dd></dl>

</div>
</div>
<a id="aa5550e528bd016acd0703ce4ccb5bc24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5550e528bd016acd0703ce4ccb5bc24">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classidocp_1_1_un_o_c_p_solver.html">UnOCPSolver</a>&amp; idocp::UnOCPSolver::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classidocp_1_1_un_o_c_p_solver.html">UnOCPSolver</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default copy assign operator. </p>

</div>
</div>
<a id="a91e7947bbeddafc689681aad5e48e141"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91e7947bbeddafc689681aad5e48e141">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classidocp_1_1_un_o_c_p_solver.html">UnOCPSolver</a>&amp; idocp::UnOCPSolver::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classidocp_1_1_un_o_c_p_solver.html">UnOCPSolver</a> &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default move assign operator. </p>

</div>
</div>
<a id="a581f205f97b4331a451197ba2a011fd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a581f205f97b4331a451197ba2a011fd5">&#9670;&nbsp;</a></span>printSolution()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void idocp::UnOCPSolver::printSolution </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em> = <code>&quot;all&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt;&#160;</td>
          <td class="paramname"><em>frames</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints the variable into console. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Name of the printed variable. Default is "all" (print all variables). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">frame_id</td><td>Index of the end-effector frames. Only used if name == "end-effector". Default is {} (do not specify any frames). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa669977194770f5488962fdcb26a1e8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa669977194770f5488962fdcb26a1e8f">&#9670;&nbsp;</a></span>saveSolution()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void idocp::UnOCPSolver::saveSolution </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path_to_file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Save the variable into file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Name of the printed variable. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">frame_id</td><td>Index of the end-effector frames. Only used if name == "end-effector". Default is {} (do not specify any frames). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adccfbe38c281e3441ae90e2c6dd20769"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adccfbe38c281e3441ae90e2c6dd20769">&#9670;&nbsp;</a></span>setSolution()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void idocp::UnOCPSolver::setSolution </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae03655825b903cde54473fc0bd8ac87b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae03655825b903cde54473fc0bd8ac87b">&#9670;&nbsp;</a></span>updateSolution()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void idocp::UnOCPSolver::updateSolution </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>line_search</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates the solution by computing the primal-dual Newon direction. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>Initial time of the horizon. Current time in MPC. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">q</td><td>Initial configuration. Size must be <a class="el" href="classidocp_1_1_robot.html#a166a0a0045a2a7815378abd2c4d857f8" title="Returns the dimensiton of the configuration.">Robot::dimq()</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>Initial velocity. Size must be <a class="el" href="classidocp_1_1_robot.html#ada145446117167b302c3fce3ee5b7dea" title="Returns the dimensiton of the velocity, i.e, tangent space.">Robot::dimv()</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">line_search</td><td>If true, filter line search is enabled. If false filter line search is disabled. Default is false. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/github/workspace/include/idocp/unocp/<a class="el" href="unocp__solver_8hpp_source.html">unocp_solver.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
